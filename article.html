<h1>Легкий шаблонизатор на PHP</h1>

<script> var CONTENTS_LEVEL = 2 </script>

<p>
Вниманию читателей предлагается простой в использовании обработчик шаблонов на языке PHP с поддержкой условных конструкций, циклов, подключения вложенных шаблонов и вызова функций. Время обработки шаблона составляет в среднем 20-70 мс.
Для работы требуется подключение <a name="download" href="http://webew.ru/f/rYHxgJVX.php" style="font-weight: bold">одного php-файла</a> (есть и на <a name="github" href="https://github.com/1234ru/websun" style="font-weight: bold">GitHub</a>). Код стабилен и применяется на нескольких работающих проектах.
</p>

<h2>Основы синтаксиса: переменные, условия, циклы</h2>

<p>
Перейдём сразу к практике и посмотрим, как выглядит шаблон, взяв для примера немного упрощенную версию HTML-кода сайта webew.ru:
</p>

[syntax=html]
<html>
<head>
	/* Многострочные комментарии - как в C или PHP */
	
	<title>{*title*}</title>
	
	<base href="{*=BASEHREF*}"> /* константа */
	
	/* условные конструкции: */
	
	{?*keywords*} 
		<meta name="keywords" content="{*keywords*}">
	{?}
	
	{?*description*}
		<meta name="description" content="{*description*}">
	{?}
	
	/* условие с негативной частью */
	<link rel="stylesheet" href=" {?*default_css*} default.css {?!} special.css {?} ">  


</head>
<body>
	<div id="logo">
		<a href=""><img src="{*logo.image*}" alt="{*logo.alt*}"></a>
	</div>

	<div id="menu">
		
		/* цикл: */
		
		{%*menu*} 
			<a href="{*menu:url*}">{*menu:title*}</a>
		{%}
	
	</div>
	
	<div id="content">
		{*content*}
	</div>
	
	<div id="footer">
		webew.ru &copy; {*year*} 
	</div>
</body>
</html>

[/syntax]

<p>
А вот соответствующий код PHP:
</p>

[syntax=php]

ini_set('pcre.backtrack_limit', 1024*1024); // (см. ниже)

$DATA['title'] = 'Webew: теория и практика веб-технологий ';

define('BASEHREF', 'http://webew.ru/');

$DATA['logo'] = array(
	'image' => 'i/logo.gif',
	'alt' => 'Логотип webew.ru'
	);

$DATA['menu'] = array(
	array('url' => 'css', 'title' => 'CSS'),
	array('url' => 'php', 'title' => 'PHP'),
	array('url' => 'seo', 'title' => 'Интернет-маркетинг'),
	array('url' => 'c', 'title' => 'C/C++')
	);

$DATA['content'] = 'Приветствуем вас на webew.ru!';


require_once 'websun.php'; // подключаем файл с шаблонизатором

$tpl = 'templates/main.tpl'; // путь к шаблону

$html = websun_parse_template_path($DATA, $tpl); // запуск шаблонизатора

echo $html; // получили обработанный шаблон, отдаем клиенту результат

[/syntax]

<p>
Несмотря на то, что переменные [syntax=*php]$DATA['keywords'][/syntax] и [syntax=*php]$DATA['description'][/syntax] не установлены, при обработке шаблона не возникнет никаких ошибок или предупреждений. 
</p>

<p>
Условная конструкция вида [syntax=*text]{?*keywords*} что-то {?}[/syntax] означает &laquo;вставить что-то, если в переменной, переданной шаблону (в данном случае $DATA) присутствует элемент keywords и при этом он не является пустой строкой, нулём, FALSE, NULL или пустым массивом&raquo;. Соответственно, конструкция [syntax=*text]{?!*keywords*} ... {?}[/syntax] срабатывает, если какое-нибудь из этих условий не выполняется.
</p>

<p>
Шаблонизатор не генерирует ошибок или предупреждений в том случае, если какой-либо из запрошенных переменных или констант вообще не существует (вместо них молчаливо будет вставлена пустая строка) поэтому формат передаваемых данных может быть нестрогим.  
</p>

<p>
В цикле ключи массива указываются через двоеточие — [syntax=*text]{*menu:title*}[/syntax], а вне цикла через точку — [syntax=*text]{*logo.image*}[/syntax]. 
</p>

<p>
Можно также обращаться к переменным глобальной области видимости, в т.ч. суперглобальным массивам. Для этого перед именем переменной нужно поставить знак доллара. Например, подстановка в шаблон переменной [syntax=*php]$_GET['foo'][/syntax] выглядит так: [syntax=*html]{*$_GET.foo*}[/syntax]. 
</p>


<h2><a name="nested-templates"></a>Вложенные шаблоны</h2>

<p>
Обычно код бывает удобно разбить на несколько шаблонов, которые затем подключать по мере необходимости. Пусть шаблон меню находится в файле menu.tpl. Тогда код из главного шаблона
</p>

[syntax=html]<div id="menu">
	{%*menu*} 
		<a href="{*menu:url*}">{*menu:title*}</a>
	{%}
</div>[/syntax]

<p>
в неизменном виде переместится в menu.tpl, а вместо него будет
</p>

[syntax=html]...
<div id="logo">
	...
</div>

{* +menu.tpl *} /* подключаем шаблон меню */

<div id="content">
...[/syntax]

<p>
Путь к шаблону может также передаваться в переменной. Например, если записать путь к шаблону меню в [syntax=*php]$DATA['menu_template'][/syntax], то подключение его примет вид
</p>

[syntax=html]{* + *menu_template* *}[/syntax]

<p>
<a name="paths"></a>
Существует несколько способов указания путей к шаблонам.
</p>

<p>
Самый наглядный метод — это указание абсолютного пути к файлу шаблона в файловой системе — что-то наподобие
<br>
<br>
[syntax=*php]$tpl = '/home/webew.ru/htdocs/templates/main.tpl'[/syntax]
<br>
<br>
Аналогично, для подключения шаблона меню с помощью абсолютного пути приходится писать
<br>
<br>
[syntax=*html]{* +/home/webew.ru/htdocs/templates/menu.tpl *}[/syntax]
</p>

<p>
Если в начале пути к шаблону отсутствует слэш, то путь интерпретируется относительно месторасположения текущего шаблона (это особенно удобно для группы связанных шаблонов, которые становится легче читать, и к тому же можно все вместе переносить, не меняя при этом путей в них, если они записаны как относительные). 
</p>

<p>
Обычно все шаблоны находятся в каком-то одном каталоге (или его дочерних) и шаблонизатору можно указать так называемый корневой каталог шаблонов — такой, относительно которого он будет интерпретировать пути к ним. Корневой каталог передается третьим аргументом:
</p>

[syntax=php]websun_parse_template_path(
	$DATA,
	$tpl,
	'/home/webew.ru/htdocs/templates'
	);[/syntax]

</p>
(если корневой каталог при вызове функции не указан, за него принимается каталог, в котором находится исполняемый скрипт).
</p>

<p>
Сообщать шаблонизатору о том, что интерпретировать путь нужно относительно корневого каталога шаблонов, следует, поместив в начало пути символ ^:
<br>
<br>
[syntax=*php]$tpl = '^/main.tpl';[/syntax]
</p>

<p>
Можно указывать также путь к шаблону относительно корневого каталога веб-сервера (используется переменная [syntax=*php]$_SERVER['DOCUMENT_ROOT'][/syntax]). Для этого в начало пути нужно поместить знак доллара.
</p>

<p>
Таким образом, путь к одному и тому же шаблону (как при его подключении его из других шаблонов, так и при вызове websun_parse_template_path) можно указать четырьмя разными способами:
</p>

[syntax=php]// пусть корневой каталог веб-сервера - /home/webew.ru/htdocs
// корневой каталог шаблонизатора - /home/webew.ru/htdocs/templates
// тогда следующие четыре записи эквивалентны:

$tpl = 'menu.tpl'; // путь относительно текущего шаблона
$tpl = '^/menu.tpl'; // относительно корневого каталога шаблонизатора
$tpl = '$/templates/menu.tpl'; // относительно корневого каталога веб-сервера
$tpl = '/home/webew.ru/htdocs/templates/main.tpl'; // абсолютный путь для ФС[/syntax]

<p>
При запуске шаблонизатора (вызов функции websun_parse_template_path) и при подключении не связанных друг с другом шаблонов рекомендуется использовать путь относительно корневого каталога шаблонизатора, в остальных случаях как правило удобнее пользоваться относительными путями. 
</p>

<p><a name="allowed_extensions"></a>По соображениям безопасности список возможных расширений файлов шаблонов по умолчанию ограничен набором [syntax=*text]*.tpl, *.html, *.css, *.js, *.xml[/syntax]. Изменить этот набор можно, воспользовавшись объектной формой вызова шаблонизатора и передав ей параметр [syntax=*text]allowed_extensions[/syntax].</p>

<!--
[syntax=php]$W = new Websun([
	'data' => $data,
	'allowed_extensions' => [ 'tpl' ] // ограничить список только tpl
]);
$html = $W->parse_template_path(путь к шаблону);[/syntax]
-->

<h2>Передача во вложенный шаблон части массива данных</h2>

<p>
Зачастую подключаемый шаблон имеет дело не со всем массивом данных, а только с какой-то его частью (например, в шаблоне меню не нужны никакие  переменные, кроме $DATA[menu]). Записывать каждый раз префикс массива в таком шаблоне становится излишним и неудобным, код шаблона загромождается. Чтобы этого избежать, подключаемому шаблону можно передать не весь массив, а лишь нужный элемент.
</p>

<p>
Вот как будут выглядеть основной шаблон и шаблон меню при таком подходе:
</p>

<p>(основной шаблон)</p>

[syntax=html]...

{* + *menu* | menu.tpl *}

/* путь к шаблону в таком случае указываем через вертикальную черту */

...[/syntax]

<p>
(или другой вариант — с передачей пути в переменной:)
</p>

[syntax=html]{* + *menu* | *menu_template* *}[/syntax]

<p>
Шаблон меню:
</p>

[syntax=html]
<div id="menu">
	{%**}
		<a href="{*:url*}">{*:title*}</a>
	{%}
</div>
[/syntax]

<p>
Конструкции вида {**}, {%**} и {?**} означают обращение к корневой переменной, переданной в шаблон.
А запись вида {* + шаблон *} есть укороченная форма конструкции {* + ** | шаблон *} (** — в подключаемый шаблон передается вся корневая переменная).  
</p>

<p>
Можно пойти еще дальше и вынести код для элемента меню в отдельный шаблон: 
</p>

[syntax=html]<div id="menu">
	{%**} {* + *:* | menu-item.tpl *} {%}	
</div>[/syntax]

<p>
Здесь конструкция *:* указывает при итерации на каждый из элементов корневого массива и означает передачу их в подключаемый шаблон. Такая запись имеет и <a href="http://webew.ru/articles/3609.webew#proper-cycles">сокращенный вариант</a>.
</p>

<p>
menu-item.tpl:
</p>

[syntax=html]<a href="{*url*}">{*title*}</a>[/syntax]

<p>
<strong>Передача элементов в подшаблон ускоряет обработку и снижает объем используемой памяти, поэтому является рекомендуемой практикой, особенно при итерации по массиву</strong>.
</p>


<h2><a name="callbacks"></a>Вызов функций и методов классов</h2>

	<p>
	Прямо из шаблонов можно вызывать функции PHP. Например:
	</p>
	
	[syntax=text]Текущее время: {* @date("H:i:s") *}.

Случайное число от 1 до $DATA['max']: {* @rand(1, *max*) *}.

Массив $DATA['list'], "склеенный" пробелом: {* @implode(" ", *list*) *}.

Литералы массивов следует передавать в виде однострочной JSON-нотации, например:
{* @implode( " ", [1,2,3] ) *}
{* @print_r( { "a":"b",  "с":[5,6,7] } ) *}[/syntax]
	
	<p>
	Функции, которые можно вызывать из шаблонов, нужно зарегистрировать в специальной переменной под названием [syntax=*php]$WEBSUN_ALLOWED_CALLBACKS[/syntax]:
	</p>
	
	[syntax=php]$WEBSUN_ALLOWED_CALLBACKS = array(
	'date',
	'rand',
	'implode',
);[/syntax]

	<p>
	При отсутствии вызываемой из шаблона функции среди зарегистрированных будет сгенерировано предупреждение.
	</p>
	
	<p>
	Переменная [syntax=*php]$WEBSUN_ALLOWED_CALLBACKS[/syntax] должна быть объявлена в глобальной области видимости.
	</p>
	
	<p>
	Результат работы функции передавать для подстановки в какой-нибудь другой шаблон, где этот результат будет принят в качестве корневой переменной. Например:
	</p>
	
	[syntax=html]{* @rand(1,10) | rand-block.tpl *}[/syntax]
	
	<p>
	Имя функции можно также передавать шаблону в переменной. Например, если [syntax=*php]$DATA['rand_function'] = 'rand'[/syntax] и [syntax=*php]$DATA['rand_template'] = 'rand-block.tpl'[/syntax], то вызов будет выглядеть так: 
	</p>
	
	[syntax=html]{* @*rand_function*(1, 10) | *rand_template* *}[/syntax]
	
	<p>
	Можно вызывать статические методы классов, а также методы экземляров объектов:
	</p>
	
	[syntax=php]$DATA['somedate'] = date_create(); // создан объект класса DateTime[/syntax]
	
	[syntax=html]{* @*somedate*->format("d.m.Y") *} - вызов метода экземпляра объекта
	
{* SomeClass::someMethod(*somedate*) *} - вызов статического метода класса[/syntax]

	<p>Регистрировать среди разрешенных к вызову следует по имени класса и метода:</p>

	 [syntax=php]$WEBSUN_ALLOWED_CALLBACKS = [
	 'DateTime::format', 
	 'SomeClass::someMethod'
];[/syntax]
	
<h2><a name="download"></a>Скачать</h2>

<p>
Чтобы начать использовать шаблонизатор, достаточно скачать и подключить его <a href="http://webew.ru/f/rYHxgJVX.php">php-файл</a>. 
</p>


<h2><a name="misc"></a>Дополнительные возможности</h2>

<p>
Ниже приводится некоторая дополнительная информация, которая может быть полезной при работе с шаблонизатором.
</p>
<br>

<p>
Помимо websun_parse_template_path, принимающей путь к шаблону, есть еще функция websun_parse_template, которой вместо пути шаблона передается его содержимое: 
</p>

[syntax=php]$DATA = ...
$template = ' 
	{*keywords*}
	...
	';
$html = websun_parse_template(
	$DATA, 
	$template,
	'/home/webew.ru/htdocs/templates' // можно не указывать
	);[/syntax]
	
<p>
(на самом деле обработчик шаблонов реализован в виде объекта, создание и настройка которого для удобства инкапсулированы в функции websun_parse_template и websun_parse_template_path; если интересно, как это происходит, можно посмотреть код этих функций)
</p>

<br>

<p>
<a name="advanced-ifs"></a>
Условия можно конструировать с использованием сравнения:
</p>

[syntax=html]{?*a=1*} a равно 1 {?}

{?!*a=1*} a не равно 1 {?}

{?*a>1*} a больше 1 {?}

{?!*a>1*} a не больше (т.е. меньше или равно) 1 {?}

{?*a=b*} а равно b {?}

{?*a="раз"*} a - это "раз" {?}[/syntax]

Условия можно делать вложенными:

[syntax=text]{?!*a=1*} 
	а не равно 1
	{?*a=10*} а равно 10 {?} 
	{?*a=b*} а равно b {?}
{?}[/syntax]

В условиях можно использовать результат работы функций:

[syntax=text]{?* @in_array(10, *a*) *} в a есть число 10 {?}
{?* @array_sum(*a*) > 15 *} сумма элементов a больше 15 {?}
{?* @array_sum(*a*) > @array_sum(*b*) *} сумма элементов a больше суммы элементов b {?}
и т.п.[/syntax]

<p>

Часть после знака сравнения интерпретируется как имя переменной, если только она не заключена в двойные кавычки (в этом случае для сравнения берется строка внутри кавычек) или же не состоит полностью из цифр (тогда берется соответствующее число).</p>

<p>
<a name="if-in-cycles"></a>
Для ясности следует отметить, что условные конструкции можно использовать и внутри циклов. Например, можно выделить активный пункт меню, поместив его в &lt;strong&gt; вместо обычных ссылок:
</p>

[syntax=php]$DATA['menu'] = array(
    array('url' => 'css', 'title' => 'CSS'),
    array('url' => 'php', 'title' => 'PHP', 'active' => TRUE), // активный пункт меню
    array('url' => 'seo', 'title' => 'Интернет-маркетинг'),
    array('url' => 'c', 'title' => 'C/C++')
    );[/syntax]

<p>
Шаблон:
</p>

[syntax=html]{%*menu*}
	{?!*menu:active*}<a href="{*menu:url*}">{*menu:title*}</a>{?}
	{?*menu:active*}<strong>{*menu:title*}</strong>{?}
{%}[/syntax]

<p>
Следует отметить, что, несмотря на то, что для конкретной записи элемент 'active' может быть вообще не установлен, при работе шаблонизатора PHP не будет генерировать предупреждений или замечаний (т.е. засорять журнал ошибок), поскольку в шаблонизаторе для таких случаев есть в т.ч. проверка с помощью isset().
</p>

<br>

<p>Иногда сократить запись можно с помощью конструкции вида [syntax=*text]{*var1|var2|var3|"раз"*}[/syntax], которая заменяется на первую из перечисленных непустую альтернативу (в данном примере, если все переменные окажутся пустыми, будет подставлена строка "раз").
</p>

<p>С помощью | можно также объединять в OR несколько условий:

[syntax=text]{?* var_1="one" | var_2="two" *} 
	var_1 равно "one" или var_2 равно "two"
{?}[/syntax]
</p>

<p>
А с помощью & - в AND:

[syntax=text]{? *var_1="one" & var_2="two" *} 
	var_1 равно "one" и при этом var_2 равно "two"
{?}[/syntax]

</p>

<br>

<p><a name="pcre.backtrack_limit"></a>
При использовании PHP 5.2.2 и выше следует обратить внимание на настройку pcre.backtrack_limit, которая ограничивает максимальный размер строки, обрабатываемой функциями семейства preg (по умолчанию это 100 Кб). Характерный признак недостаточно большой величины pcre.backtrack_limit — получение пустой строки в результате обработки шаблона в случае, когда этого быть не должно. Избежать этого можно, увеличив это значение (лучше с большим запасом — к растрате ресурсов это не приведет): 

[syntax=php]ini_set('pcre.backtrack_limit', 1024*1024); // 1 Mб[/syntax]
</p>

<br>
<br>

<p>
Итерация по одномерному массиву (вида [syntax=*php]$DATA['list'] = array(10,20,30,40,50)[/syntax]) делается очень просто. Например, вывести его элементы по одному в строке можно так:
</p>

[syntax=*html]{%*list*} {*list:*}<br> {%}[/syntax]

<p>
<a name="nested-cycles"></a>
А вообще можно использовать массивы любой размерности (не только двумерные), а циклы строить — любой вложенности:
</p>

[syntax=php]$DATA['cities'] = array(
	array(
		'id' => 1,
		'title' => 'Москва',
		'codes' => array(77, 97, 99, 177, 197),
		'neighbours' =>
			array('id' => 25, 'title' => 'Калуга'),
			array('id' => 32, 'title' => 'Тула'),
			array('id' => 47, 'title' => 'Владимир'),
			array('id' => 59, 'title' => 'Рязань'),
			array('id' => 134, 'title' => 'Тверь'),
			array('id' => 15, 'title' => 'Смоленск'),
			array('id' => 37, 'title' => 'Ярославль')
			),
		),
	array(
		'id' => 2,
		'title' => 'Санкт-Петербург',
		'codes' => array(78, 98),
		'neighbours' =>
			array('id' => 69, 'title' => 'Петрозаводск'),
			array('id' => 78, 'title' => 'Вологда'),
			array('id' => 10, 'title' => 'Новгород'),
			array('id' => 117, 'title' => 'Псков')
		),
	...
	);[/syntax]

<p>Шаблон:</p>

[syntax=html]
{%*cities*}
	<h1>{*cities:title*}</h1>
	
	<p>
	Автомобильные коды:
	{%*cities:codes*}
		{*cities:codes:*} /* список кодов - одномерный массив */
	{%}
	</p>
	
	<p>
	Соседние регионы:
	<br> 
	{%*cities:neighbours*}
		<a href="/city/{*cities:neighbours:id*}">
		{*cities:neighbours:title*}
		</a>
		<br>
	{%}
	</p>
{%}
[/syntax]

<p>
К элементам такого массива можно обращаться и вне цикла, например,  {*cities.0.neighbours.1.title*} — 'Тула' и т.п. 
</p>

<p><a name="KEY"></a>Внутри цикла есть также возможность обратиться к ключу массива - с помощью инструкции ^KEY, например:</p>

[syntax=*text]{%*cities*}
	№ {*cities:^KEY*}. {*cities:title*}<br>
{%}[/syntax]

<p><a name="iN"></a>Аналогично, ^i и ^N внутри цикла — порядковый номер элемента в массиве, начиная с 0 и 1 соответственно.</p>

<p><a name="COUNT"></a>А с помощью ^COUNT можно оперировать числом элементов в массиве:</p>

[syntax=text]Всего городов: {*cities^COUNT*}.
(перед ^COUNT нет двоеточия, т.к. его можно использовать и вне циклов)[/syntax]

<br>
<br>

<p><a name="proper-cycles"></a>
Подключение шаблонов внутри циклов можно переписать покороче:
</p>

[syntax=html]/* можно так: */
{%*menu*} {* +*menu:* | menu-item.tpl *} {%}

/* но лучше - так (перед именем передаваемой в шаблон переменной появился знак %) */
{* +*%menu* | menu-item.tpl *}[/syntax]

<p>
Аналогичное сокращение действует и для подключения шаблона внутри условия:
</p>

[syntax=html]/* можно так: */
{?*menu*} {* +*menu* | menu-item.tpl *} {?}

/* но лучше - так (перед именем переменной появился знак вопроса) */
{* +*?menu* | menu-item.tpl *}[/syntax]


<p>
Есть возможность передавать в переменной не путь к шаблону, а непосредственно его содержимое (иногда это бывает удобно). Пользоваться этим можно так же, как и обычными вложенными подшаблонами:  
</p>

[syntax=text]
	{* + >*tpl* *}
		/* фактически дополняем переменной  
		текущий шаблон; так можно, грубо говоря,
		сделать её содержимое динамическим
		с помощью шаблонизатора */
		
	{* + *subvar* | >*tpl* *} 
		/* можно и часть массива */
		
	{* + *?subvar* | >*tpl* *} 
		/* если в subvar что-то есть.. */
		
	{* + *%subvar* | >*tpl* *} 
		/* пройтись по переменной в цикле */ 
	
	{* + *@module()* | >*tpl* *}
		/* использовать переменную как шаблон для подстановки результатов работы функции */
[/syntax]

<br>
<br>

<p>
<a name="no_global_vars"></a>
Можно отключить возможность использовать в шаблоне переменные глобальной области видимости и суперглобальные переменные ([syntax=*php]$_GET[/syntax], [syntax=*php]$_SERVER[/syntax], [syntax=*php]$_COOKIES[/syntax] и пр.). Для этого нужно передавать функциям [syntax=*php]websun_parse_template_path()[/syntax] и [syntax=*php]websun_parse_template()[/syntax] четвертый аргумент, равный [syntax=*php]TRUE[/syntax]:
</p>
[syntax=php]websun_parse_template_path(
    $DATA,
    $template_path,
    '/home/webew.ru/htdocs/templates',
    TRUE
    ); 
[/syntax]
<p>
Все такие переменные при обработке шаблонов будут заменены на пустые строки.
</p>

<!--
Причины не использовать ключи массива, равных пустой строке.

{*a:b*} пришлось бы тогда писать как {*a:.b*}
т.к., строго говоря, : надо разворачивать в .KEY, а не в .KEY.
тогда корректно было бы {*a:.*} -> {*a.KEY.*}, а {*a:*} -> {*a.KEY*}
а так последняя точка убирается, чтобы корректно обрабатывалось то, что получается после обработки цикла - типа {*a.1.*} и т.п.
-->